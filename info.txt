
Four different levels of design:
- simple consistent card back
- accurate image for each DS (design language for representing structural aspects)
- overall layout for the card information (plus mod knobs for expansion decks)
- fancy image for each DS (should to be able to commission these widely)

Art for data structure cards:
1. Back of card
  - separate for Abstract and Concrete
2. Datastructure representation pictures
  - One possible sub-project is a visual language for data structure definition/specification
3. Individual card art
  - Fanciful representations of the data structures
4. Card layout
  - Layout of specific cards
  - Probably separate for abstract and concrete
  - Incorporates the representation with some detailed information about a particular structure



------ CARDS --------


ABSTRACT
========

basic operations are under the name. 
optional operations start with a star.


------------------------

STACK

push: add to end
pop:  remove from end

*peek: get value of next pop
*count: get length

implementations:
:: linked list: O(1) 
:: array: O(1), but fixed size [you can only have one at a time], mutation?
:: dynamic array: O(1), amortized, (mutation?)

--> historical note: Turing was the first one to refer to a stack, called operations 'bury' and 'unberry'
--> sigs from Turing's grand-students


------------------------

QUEUE

enqueue: add to end
dequeue: remove from other end

*peek:   get value of next dequeue
*count:  get length

implementations:
:: doubly linked list: O(1), mutation
:: linked list w/ tail pointer (add to tail): mutation
:: array: O(1) if you treat it like a ring buffer, mutation, fixed size
:: dynamic array: amortized O(1), mutation
:: banker's queue: O(1), amortized, [persistent with more work], [non-amortized with more work]
    -> Tarjan: persistent
    -> Okasaki: amortized

--> history?

--------------------

DEQUE

push: add to end
pop: remove from end
shift: add to front
unshift: remove from front
peek-last: get value of end
peek-first: get value of front

*count:  get length

implementations:
:: doubly linked list: O(1), mutation
:: array: O(1) if you treat it like a ring buffer, mutation, fixed size
:: fully persistent is *tricky*, catenable [], confluently persistent [mergable, like github, makes a DAG], else ephemeral. partially persistent is read-only. 

--> history?

------------------------


CONCRETE
========

The operations under the data structure name follow this structure:
SPEED name: description
Then maybe some extra properties if it has any

------------------------

LINKED LIST

FAST push: add to end
FAST pop: remove from end

DIRE shift: add to front
DIRE unshift: remove from front

SLOW peek-last: get value of end
SLOW peek-first: get value of front
SLOW count: get length

* fully persistent 

------------------------

DOUBLY-LINKED LIST

FAST push: add to end
FAST pop: remove from end

FAST shift: add to front
FAST unshift: remove from front

FAST peek-last: get value of end
FAST peek-first: get value of front
FAST count: get length

* ephemeral, mutates

------------------------

BATCHED QUEUE

FAST push: add to end
FAST pop: remove from end

FAST shift: add to front
FAST unshift: remove from front

FAST peek-last: get value of end
FAST peek-first: get value of front
SLOW count: get length

* amortized, persistent

- image: one stack upright, another next to it but upside down.

- aside: you can do anything with just two stacks -- it's turing equivalent. 

------------------------

HAMT

Ctrie

RRB-tree




lalalal
===================================

A list of all the concrete data structures. Possibly some general notes on them too, but note that the card details section contains notes pertaining specifically to concrete data structure cards as well. Note also that each card should have its own page, and this will just link to all of them.

LINKED LIST

FAST push: add to end FAST pop: remove from end

DIRE shift: add to front DIRE unshift: remove from front

SLOW peek-last: get value of end SLOW peek-first: get value of front SLOW count: get length

fully persistent



DOUBLY-LINKED LIST

FAST push: add to end FAST pop: remove from end

FAST shift: add to front FAST unshift: remove from front

FAST peek-last: get value of end FAST peek-first: get value of front FAST count: get length

ephemeral, mutates



BATCHED QUEUE

FAST push: add to end FAST pop: remove from end

FAST shift: add to front FAST unshift: remove from front

FAST peek-last: get value of end FAST peek-first: get value of front SLOW count: get length

amortized, persistent(ish)

image: one stack upright, another next to it but upside down.

aside: you can do anything with just two stacks -- it's turing equivalent.